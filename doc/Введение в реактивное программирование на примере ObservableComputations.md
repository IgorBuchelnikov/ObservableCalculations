# Введение в реактивное программирование на примере ObservableComputations

В данной статье отвечу на следующие вопросы:

1. Что такое реактивное программирование?  *Общее описание реактивного программирования  и других связанных с ним понятий без привязки к конкретным реализациям. Прочитав это раздел вы чётко увидите что объединяет все реализации реактивного программирования*.
   1. Что такое декларативное программирование?
   2. Что такое императивное программирование?
   3. Как связаны реактивное, декларативное и императивное программирование?
   4. Что хорошего в декларативном программировании?
   5. Варианты реализации декларативного программирования
   6. Варианты реализации реактивного программирования
2. ObservableComputations - кроссплатформенная реализация реактивного программирования в .NET

## Что такое реактивное программирование?

Как следует из названия реактивное программирование это *программирование реакций* на *события*. Важно понимать что в данном определении подразумевается по *событиями* и под *программированием*. 

### Паттерн "Событие"

Интуитивно мы все понимаем что такое событие. Когда происходит событие на него кто-то может отреагировать. Бывает, что виновник события сам не знает кто может отреагировать. Бывает, что кто-то может попросить потенциального виновника события уведомить его в случае возникновения события. Нечто подобное моделируется в программировании. Примерами событий, с которыми наверное сталкивался каждый программист являются события пользовательского ввода: клики мышью, нажатия клавиш клавиатуры. Важно понимать, что события это паттерн проектирования имеющий множество возможных реализаций. В архитектуре зданий аналогом паттерна является окно. Все окна похожи друг на друга, но реализация может отличаться. Чтобы понять суть в чём заключается паттерн "Событие", в чем суть всех его реализаций начну с примитивной реализации в ООП.

Допустим в комнате есть несколько лампочек, и какие-то лампочки необходимо включить, когда человек входит в комнату. Тип (по типом далее я буду подразумевать класс или интерфейс) *Room* будет содержать список элементов типа *Lamp*. Мы вызываем метод *Lamp.TurnOn()* из метода *Room.PersonEntered()* для каждой лампочки из списка. 

В этом примере тип *Room* это источник события *PersonEntered*. Тип *Lamp* это слушатель события. В более общей реализации событий вместо типа *Lamp* может выступать тип *Device* с методом *TurnOn()*, либо тип *EventListener* (слушатель события) с методом *ProcessTheEventOccurrence* (обработать возникновение события). Тип *Lamp* должен являться наследником типа *Device* или типа *EventListener*, либо же тип *Lamp* должен содержать член типа *EventListener*. Вместо того чтобы в методе *Room.PersonEntered()* проходить в цикле все ссылки на экземпляры типа *Lamp* (*Device* или *EventListener*), можно создать тип *EventSource* со списком элементов типа *EventListener* и методом *ProcessTheEventOccurrence*, который будет при возникновении события вызывать метод *EventListener.ProcessTheEventOccurrence* для каждого элемента списка. Соответственно у типа *EventSource* должен быть метод *Subscribe(EventListener)* и, опционально, *Unsubscribe(EventListener)*.  Тип *Room* будет содержать ссылку на экземпляр типа *EventSource*, и в методе *Room.PersonEntered()* будет вызов метода *EventSource.ProcessTheEventOccurrence()*. 

В такой общей реализации можно убрать зависимость между типом *Room* и типом *Lamp*. В примитивной реализации описанной выше зависимость между типом *Room* и *Lamp* неизбежна.

Иногда слушатель события, называется подписчиком. Но нужно понимать, что в этом случае подписчик это не тот кто вызывает метод *EventSource.Подписаться*, а тот в чьём контексте выполняется код реагирующий на событие при его возникновении. Ещё один синоним - обработчик события.

События по разному реализованы на разных языках и платформах. Где это часть языка, например в C#. Где-то реализация содержится в стандартной библиотеке, как в Java. C# и Java позволяют создавать альтернативные реализации событий, аналогичные той которая описана выше. Важно понимать суть этих реализаций. Во всех реализациях Вы сообщаете источнику события какой код нужно вызвать при возникновении события. Это называется подпиской. 

Чем могут отличаться реализации? Здесь можно пофантазировать.

- Возможно ли сделать несколько подписок разными слушателями? 
- Возможно ли сделать несколько подписок с одним и тем же слушателем?
- Может ли один слушатель подписаться на разные события?
- Возможна ли отписка?
- Как осуществляется отписка? В приведенном выше примере методу *Unsubscribe* класса *EventSource* передаёт параметр типа *EventListener*. Это один из вариантов реализации. Ещё один вариант заключается в том, что метод *EventSource.Подписаться(EventListener)* будет возвращать экземпляр класса *Subscption*, а метод *Unsubscribe* класса *EventSource* будет принимать этот экземпляр в качестве параметра. На этом варианты не заканчиваются. Можно например у класса *EventListener* сделать методы *Subscribe(EventSource)* и *Unsubscribe(EventSource)*.
- Являются ли операции обработки события, подписки и отписки потокобезопасными. То есть можно ли обрабатывать событие, подписываться и описываться параллельно в разных потоках.
- Что происходит если код слушателя выполняется слишком долго? Нужен ли таймаут? Возможно ли задать таймаут для каждого слушателя отдельно?  
- Что произойдёт если в данный момент происходит вызов кода какого-либо слушателя (обработка события)
- Как обрабатываются ошибки (исключения) в коде слушателей? Игнорируются (слушатель должен сам обрабатывать свои ошибки)? Источник события делает делает ещё одну попытку вызвать код слушателя? Источник события вызывает у слушателя специальный код обработки ошибок.
- В случае если на событие можно подписать несколько слушателей, в каком порядке они должны вызываться при возникновении события? В порядке подписки? Можно задать приоритет?
- В качестве слушателя события используется тип *Слушатель* или можно в качестве слушателя можно использовать ссылка на метод (если язык программирования позволяет), который будет вызван при возникновении события?
- В случае если на событие можно подписать несколько слушателей, можно ли запустить методы *EventListener.ProcessTheEventOccurrence* параллельно (в нескольких потоках)?

От ответов на эти вопросы часто зависит скорость работы событий, удобство работы с ними. Скорость будет важна если подписки, описки, возникновения событий происходят часто.

В библиотеке ReactiveExtentions для .NET (для других языков есть аналогичные библиотеки) содержится своя реализация паттерна "Событие". Интерфейс *ISubject* это источник событий, интерфейс *IObserver* это слушатель события. Как Вы могли заметить в типе *EventSource* есть метод *ProcessTheEventOccurrence*, метод с таким же названием есть в типе *EventListener*. Поэтому в ReactiveExtentions интерфейс *ISubject* наследует IObserver. Интерфейс *ISubject* также реализует интерфейс *IObservable*, в котором есть единственный метод для подписки на событие. Этот метод возвращает тип *IDisposable*, при вызове метода *IDisposable.Dispose* происходит отписка. 

Зачем нужно было создавать ещё одну реализацию паттерна "Событие" в ReactiveExtentions, если в каждом языке она уже своя реализация? Для унификации. Для того чтобы ReactiveExtentions в разных языках имели одинаковый API, так как встроенные реализации паттерна "Событие" отличаются друг от друга в разных языках. ReactiveExtentions для .NET включают в себя средства для преобразования событий .NET в события ReactiveExtentions для .NET. Я говорю о методе FromEventPattern.

### Программирование реакций на события

Вы можете сказать занимаетесь программированием реакций на события постоянно и зачем вся эта шумиха вокруг реактивного программирования. Дело в том, что библиотеки реактивного программирования позволяют программировать реакции на события более эффективно. То есть код получается короче, легче читается и меньше вероятность допустить ошибку. Конечно в примере события, которое описано выше, всё просто и кажется что упрощать нечего. 

Давайте усложним. Допусти у нас помимо события *Room.PersonEntered*, есть событие *Room.PersonExited* (человек вышел). Когда человек выходит из комнаты лампочки нужно выключать. Ещё представьте, что в доме есть шаловливые дети, которые повадились мигать лампочками вбегая и выбегая из комнаты. Нужно принимать меры, иначе лампочки сломаются. 

Во-первых лампочку нужно включать с небольшим запозданием после возникновения события *Room.PersonEntered*, во-вторых, если за период ожидания возникло событие *Room.PersonExited*, то ожидание нужно отменить и лампочку не включать. Реализовать эту логику не так просто как кажется на первый взгляд, но с помощью ReactiveExtentions она описывается просто и понятно.

