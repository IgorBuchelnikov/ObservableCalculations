<#@ template  debug="true" hostSpecific="true" #>
<#@ output extension="generated.cs" #>
<#@ Assembly Name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ output extension=".generated.cs"#>
<#@ include file=".\ExtensionMethods.ttinclude" #>
using System;
using System.Linq;
using System.Collections.Generic;
using System.ComponentModel;
using System.Collections.ObjectModel;
using IBCode.ObservableComputations.Common;
using IBCode.ObservableComputations.Common.Interface;

namespace IBCode.ObservableComputations
{
	public static partial class ExtensionMethods
	{
<#
	var extentionMethodGroups = GetExtentionMethods().GroupBy(em => em.Name).OrderBy(emg => emg.Key).ToArray();
	foreach (var extentionMethodGroup in extentionMethodGroups)
	{

#>
		#region <#=extentionMethodGroup.Key#>

<#


		foreach (ExtentionMethod extentionMethod in extentionMethodGroup)
		{

#>
		[ObservableComputationsCall]
		public static <#=extentionMethod.TypeName#> <#=extentionMethod.Name#><#=extentionMethod.GenericParameters#>(this
<#
			int index = 0;
			var signatureArguments = extentionMethod.Arguments.Where(a => a.DefaultValue == null);
			foreach (ExtentionMethodArgument argument in signatureArguments )
			{
#>
			 <#=argument.Type#> <#=argument.Name#><#=index == signatureArguments.Count() - 1 ? ")" : ","#>
<#
				index++;
			}

#>
		{
			return new <#=extentionMethod.TypeName#>(
<#
			index = 0;
			foreach (ExtentionMethodArgument argument in extentionMethod.Arguments)
			{
#>
				<#=argument.Name#>: <#=argument.DefaultValue == null ? argument.Name : argument.DefaultValue#><#=index == extentionMethod.Arguments.Count - 1 ? ");" : ","#>
<#
				index++;
			}
#>
		}

<#
		}
#>
		#endregion
<#
    }
#>
	}
}
<#+

#>
