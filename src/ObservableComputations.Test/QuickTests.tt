// Copyright (c) 2019-2021 Buchelnikov Igor Vladimirovich. All rights reserved
// Buchelnikov Igor Vladimirovich licenses this file to you under the MIT license.
// The LICENSE file is located at https://github.com/IgorBuchelnikov/ObservableComputations/blob/master/LICENSE

<#@ template  debug="true" hostSpecific="true" #>
<#@ output extension="generated.cs" #>
<#@ Assembly Name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #> 
<#@ import namespace="System.Text.RegularExpressions" #> 
<#@ include file=".\..\ObservableComputations\ExtensionMethods.ttinclude" #>
using System;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Collections.ObjectModel;
using NUnit.Framework;
using ObservableComputations;

namespace ObservableComputations.Test
{
	[TestFixture(false)]
	[TestFixture(true)]
	public partial class QuickTests : TestBase
	{
<#
	foreach (var extensionMethodGroup in 
		GetExtensionMethods().Where(em => 
			em.Name != "Using" 
			&& em.Name != "Computing"
			&& em.Name != "Differing"
			&& em.Name != "PreviousTracking"
			&& em.Name != "WeakPreviousTracking"
			&& em.Name != "PropertyAccessing"
			&& em.Name != "CollectionDispatching"
			&& em.Name != "ScalarDispatching"
			&& em.Name != "ConcurrentDictionaring"
			&& em.Name != "ScalarPausing"
			&& !em.Arguments.Any(ema => IsComputingArgument(ema)))
		.GroupBy(em => em.Name).OrderBy(emg => emg.Key))
	{

#>
		#region <#=extensionMethodGroup.Key#>

<#

		int testNum = 0;
		foreach (ExtensionMethod extensionMethod in extensionMethodGroup)
		{
			testNum++;

			if (extensionMethod.Name == "CollectionPausing")
			{
			}

			var arguments = new List<(string variableType, string name, string result, string sourceAccessor, string scalarType, bool isCombinatorical)>();
			var signatureArguments = extensionMethod.ArgumentsWithoutDefaultValue;
			foreach (ExtensionMethodArgument argument in signatureArguments )
			{
				var argumentValue = getArgumentValue(argument.Type, argument.Name, extensionMethod.Name);
				arguments.Add((argumentValue.variableType, argument.Name, argumentValue.result, argumentValue.sourceAccessor, argumentValue.scalarType, argumentValue.isCombinatorical));
			}

			var combinatoricalArguments = arguments.Where(a => a.isCombinatorical).ToArray();
#>
		
		[Test, Combinatorial]
		public void Test<#=extensionMethod.Name#><#=testNum.ToString("00")#>(<#=combinatoricalArguments.Length == 0 ? ")" : ""#>
<#			
			for (int combinatoricalArgumentIndex = 0; combinatoricalArgumentIndex < combinatoricalArguments.Length; combinatoricalArgumentIndex++)
			{
				var argument = combinatoricalArguments[combinatoricalArgumentIndex];
#>			[Values(<#=string.Join(", ", getScalarAlternativeValues(argument.variableType, argument.name, extensionMethod.Name))#>)] <#=argument.variableType#> <#=argument.name#><#=combinatoricalArgumentIndex < combinatoricalArguments.Length - 1 ? ",\n" : ")\n"#><#
			}
#>
		{
<#
			foreach (var argument in arguments.Where(a => !a.isCombinatorical))
			{

#>
			<#=argument.variableType#> <#=argument.name#> = <#=argument.result#>;
<#
			}

			string genericParamsValues = getTestType(extensionMethod.GenericParameters, extensionMethod.Name);
#>
			OcConsumer consumer = new OcConsumer();
			var testing = <#=arguments.First().name#>.<#=extensionMethod.Name#><#=genericParamsValues#>(<#=arguments.Count == 1 ? ").For(consumer);" : ""#>
<#
			int index = 0;
			foreach (var argument in arguments.Skip(1))
			{
#>
				<#=argument.name#><#=index == arguments.Count() - 2 ? ").For(consumer);" : ","#>
<#
					index++;
			}
#>

<#
			foreach (var argument in arguments)
			{
				if (
						(
							(extensionMethod.Name == "Concatenating" || extensionMethod.Name == "Uniting") 
							&& (argument.name == "source1" || argument.name == "source2" || argument.name == "source1Scalar" || argument.name == "source2Scalar")
						)
						|| (extensionMethod.Name == "Paging" && argument.name == "initialPage")
						|| (extensionMethod.Name == "CollectionPausing" && argument.name == "initialIsPaused")
					)
					continue;
#>
			Assert.AreEqual(<#=argument.name#>, testing.<#=FirstCharToUpper(argument.name)#>);
<#
			}
#>

			void test()
			{
				testing.ValidateConsistency();
<#
			foreach (var argument in arguments.Where(a => (a.name.Contains("source") || a.name.Contains("innerSource") || a.name.Contains("outerSource") || a.name.Contains("leftSource") || a.name.Contains("rightSource")) && !IsCollectionOfCollectionsArgument(extensionMethod.Name, a.name)))
			{
				string scalarValueAccessor = argument.variableType.Contains("Scalar") ? ".Value" : "";
#>
				var <#=argument.name#>Value = ((ObservableCollection<Item>)((<#=argument.scalarType#>)<#=argument.name#><#=scalarValueAccessor#>)<#=argument.sourceAccessor#>);

				if (<#=argument.name#>Value != null)
				{		
					<#=argument.name#>Value.Insert(2, new QuickTests.Item(1, true));
					testing.ValidateConsistency();
					<#=argument.name#>Value[3] = new QuickTests.Item(7, true);
					testing.ValidateConsistency();
					<#=argument.name#>Value.RemoveAt(3);
					testing.ValidateConsistency();
					<#=argument.name#>Value.Move(1, 3);
					testing.ValidateConsistency();
					<#=argument.name#>Value[2].Active = !<#=argument.name#>Value[2].Active;
					testing.ValidateConsistency();
					<#=argument.name#>Value[2].Num = <#=argument.name#>Value[2].Num + 1;
					testing.ValidateConsistency();
					<#=argument.name#>Value.RemoveAt(0);
					testing.ValidateConsistency();
					<#=argument.name#>Value.RemoveAt(1);
					testing.ValidateConsistency();
					<#=argument.name#>Value.Insert(0, new QuickTests.Item(1, true));
					testing.ValidateConsistency();
					<#=argument.name#>Value.Insert(0, new QuickTests.Item(2, true));
					testing.ValidateConsistency();
				}
<#
			}

			var sourcesArgument = arguments.Where(a => IsCollectionOfCollectionsArgument(extensionMethod.Name, a.name));
			if (sourcesArgument.Count() != 0)
			{
				string scalarValueAccessor = sourcesArgument.First().variableType.Contains("Scalar") ? ".Value" : "";
#>
				var <#=sourcesArgument.First().name#>Value = ((ObservableCollection<ObservableCollection<Item>>)((<#=sourcesArgument.First().scalarType#>)<#=sourcesArgument.First().name#><#=scalarValueAccessor#>)<#=sourcesArgument.First().sourceAccessor#>);
				
				if (<#=sourcesArgument.First().name#>Value != null)
				{
					<#=sourcesArgument.First().name#>Value.Insert(0, new ObservableCollection<Item>(new []{new Item(1, true)}));
					testing.ValidateConsistency();
					<#=sourcesArgument.First().name#>Value.RemoveAt(1);
					testing.ValidateConsistency();
					<#=sourcesArgument.First().name#>Value.Move(0, 1);
					testing.ValidateConsistency();
				}

<#
			}

#>

				IList listSource;
<#
			if (sourcesArgument.Count() == 0)
				foreach (var argument in arguments.Where(a => (a.Item2.Contains("source") || a.Item2.Contains("innerSource") || a.Item2.Contains("outerSource"))))
				{
					string scalarValueAccessor = argument.Item1.Contains("Scalar") ? ".Value" : "";
#>
				listSource = ((IList)((<#=argument.scalarType#>)<#=argument.name#><#=scalarValueAccessor#>)<#=argument.sourceAccessor#>);
				if (listSource != null)
				{
					listSource.Clear();
					testing.ValidateConsistency();
				}

<#
				}

			if (sourcesArgument.Count() == 0)
				foreach (var argument in arguments.Where(a => (a.Item2.Contains("source") || a.Item2.Contains("innerSource") || a.Item2.Contains("outerSource")) && !a.Item2.Contains("sources")))
				{
					string scalarValueAccessor = argument.Item1.Contains("Scalar") ? ".Value" : "";
#>
				if (<#=argument.name#>Value != null)
				{
					<#=argument.name#>Value.Insert(0, new QuickTests.Item(1, true));
					<#=argument.name#>Value.Insert(1, new QuickTests.Item(2, true));
					<#=argument.name#>Value.Insert(2, new QuickTests.Item(3, true));
					<#=argument.name#>Value.Insert(3, new QuickTests.Item(3, true));
					<#=argument.name#>Value.Insert(4, new QuickTests.Item(3, true));
					testing.ValidateConsistency();
				}
<#
				}

			if (sourcesArgument.Count() != 0)
			{
				string scalarValueAccessor = sourcesArgument.First().Item1.Contains("Scalar") ? ".Value" : "";
#>
				if (<#=sourcesArgument.First().name#>Value != null)
				{
					<#=sourcesArgument.First().name#>Value.Insert(0, new ObservableCollection<Item>(new []{new Item(1, true), new Item(2, true), new Item(3, true), new Item(4, true), new Item(5, true)}));
					<#=sourcesArgument.First().name#>Value.Insert(0, new ObservableCollection<Item>(new []{new Item(6, true), new Item(7, true), new Item(8, true), new Item(8, true), new Item(10, true)}));
					testing.ValidateConsistency();
				}

<#
			}
#>
			}

			test();
<#


			var scalarArguments = arguments.Where(a => a.Item2.ToUpper().Contains("SCALAR"));
			var scalarSourceArguments = scalarArguments.Where(a => a.Item2.ToUpper().Contains("SOURCE"));
			var scalarNotSourceArguments = scalarArguments.Where(a => !a.Item2.ToUpper().Contains("SOURCE"));

			foreach (var argument in scalarNotSourceArguments.Concat(scalarSourceArguments))
			{
#>

			((Scalar<<#=argument.scalarType#>>)<#=argument.name#>).Touch();
			test();
<#				
				IEnumerable<string> scalarAlternativeValues = getScalarAlternativeValues(argument.scalarType, argument.name, extensionMethod.Name);

				foreach (var scalarAlternativeValue in scalarAlternativeValues)
				{
#>
			((Scalar<<#=argument.scalarType#>>)<#=argument.name#>).Change(<#=scalarAlternativeValue#>);
			test();
<#	
				}
			}
#>
			consumer.Dispose();
		}
<#
		}
#>
		#endregion
<#
	}
#>
	}
}
<#+
	private string FirstCharToLower(string name)
	{
		return name[0].ToString().ToLower() + name.Substring(1, name.Length - 1);
	}

	private string FirstCharToUpper(string name)
	{
		return name[0].ToString().ToUpper() + name.Substring(1, name.Length - 1);
	}

	private string getTestType(string type, string extensionMethodName)
	{
		type = type.Replace("TSourceItem, TResult, TResult", "int, int, int");
		if (extensionMethodName == "Aggregating") type = type.Replace("TSourceItem, TResult", "int, int");
		if (extensionMethodName == "Maximazing" 
			|| extensionMethodName == "Minimazing"
			|| extensionMethodName == "Summarizing"
			|| extensionMethodName == "Averaging"
			|| extensionMethodName == "Ordering"
			|| extensionMethodName == "ThenOrdering") 
			type = type.Replace("TSourceItem", "int");
		type = type.Replace("TSourceItem1", "Item");
		type = type.Replace("TSourceItem2", "Item");
		type = type.Replace("TOuterSourceItem", "Item");
		type = type.Replace("TInnerSourceItem", "Item");
		type = type.Replace("TLeftSourceItem", "Item");
		type = type.Replace("TRightSourceItem", "Item");
		type = type.Replace("TSourceItem", "Item");
		type = type.Replace("TResultItem", "object");
		type = type.Replace("TKey", "int");
		type = type.Replace("TValue", "int");
		type = type.Replace("TOrderingValue", "int");
		if (extensionMethodName == "Averaging") 
			type = type.Replace("TResult", "double");
		else
			type = type.Replace("TResult", "int");
		type = type.Replace("ObservableComputations.IReadScalar", "Scalar");
		return type;
	}

	private string iReadScalarToScalar(string type)
	{
		type = type.Replace("IReadScalar", "Scalar");
		return type;
	}

	private (string result, string sourceAccessor, string variableType, string scalarType, bool isCombinatorical) getArgumentValue(string type, string argumentName, string extensionMethodName)
	{
		string checkingType = type;
		string result = null;
		string sourceAccessor = "";
		string variableType = null;

		bool scalar = false;
		Regex regex = new Regex(@"ObservableComputations\.IReadScalar<(?<scalarType>.+)>");
		MatchCollection matchCollection = regex.Matches(type);
		if (matchCollection.Count > 0)
		{
			checkingType = matchCollection[0].Groups["scalarType"].Value;
			scalar = true;
			if (extensionMethodName == "Paging")
			{
			}
		}

		switch (checkingType)
		{
			case "System.Collections.Specialized.INotifyCollectionChanged":
				if (extensionMethodName == "Aggregating" 
					|| extensionMethodName == "Maximazing"
					|| extensionMethodName == "Minimazing"
					|| extensionMethodName == "Summarizing"
					|| extensionMethodName == "Averaging"
					|| extensionMethodName == "Ordering")
				{
					result = "getItems().Selecting(i => i.Num)";
					variableType = "Selecting<Item, int>";
					sourceAccessor = "?.Source";
				}
				else if (extensionMethodName == "StringsConcatenating")
				{
					result = "getItems().Selecting(i => i.Num.ToString())";
					variableType = "Selecting<Item, string>";
					sourceAccessor = "?.Source";
				}
				else
				{
					result = IsCollectionOfCollectionsArgument(extensionMethodName, argumentName)
						? "getCollectionsOfItems()" : "getItems()";
				}
				break;
			case "ObservableCollection<TSourceItem1>":
			case "ObservableCollection<TSourceItem2>":
			case "ObservableCollection<TOuterSourceItem>":
			case "ObservableCollection<TInnerSourceItem>":
			case "ObservableCollection<TLeftSourceItem>":
			case "ObservableCollection<TRightSourceItem>":
			case "ObservableCollection<TSourceItem>":
				if (extensionMethodName == "Aggregating"					
					|| extensionMethodName == "Maximazing"
					|| extensionMethodName == "Minimazing"
					|| extensionMethodName == "Summarizing"
					|| extensionMethodName == "Averaging"
					|| extensionMethodName == "Ordering")
				{
					result = "getItems().Selecting(i => i.Num)";
					variableType = "Selecting<Item, int>";
					sourceAccessor = "?.Source";
					checkingType = "ObservableCollection<int>";
				}
				else if (extensionMethodName == "StringsConcatenating")
				{
					result = "getItems().Selecting(i => i.Num.ToString())";
					variableType = "Selecting<Item, string>";
					sourceAccessor = "?.Source";
					checkingType = "ObservableCollection<string>";
				}
				else
				{
					result = "getItems()";
				}
				break;
			case "ObservableCollection<ObservableCollection<TSourceItem>>":
				result = "getCollectionsOfItems()";
				break;
			case "TSourceItem":
				if (extensionMethodName == "Maximazing"
					|| extensionMethodName == "Minimazing")
					result = "0";
				else if (extensionMethodName == "FirstComputing"
					|| extensionMethodName == "LastComputing")
					result = "null";
				else
					result = "new QuickTests.Item(1, true)";
				break;
			case "System.Linq.Expressions.Expression<System.Func<TSourceItem, TKey>>":
			case "System.Linq.Expressions.Expression<System.Func<TOuterSourceItem, TKey>>":
			case "System.Linq.Expressions.Expression<System.Func<TInnerSourceItem, TKey>>":
			case "System.Linq.Expressions.Expression<System.Func<TLeftSourceItem, TKey>>":
			case "System.Linq.Expressions.Expression<System.Func<TRightSourceItem, TKey>>":
				result =  "i => i.Id";
				break;
			case "System.Linq.Expressions.Expression<System.Func<TSourceItem, TValue>>":
				result =  "i => i.Num";
				break;
			case "System.Collections.Generic.IEqualityComparer<TSourceItem>":
				result =  "EqualityComparer<Item>.Default";
				break;
			case "System.Collections.Generic.IEqualityComparer<TKey>":
				result =  "EqualityComparer<int>.Default";
				break;
			case "System.Linq.Expressions.Expression<System.Func<TSourceItem, bool>>":
				result =  "i => i.Active";
				break;
			case "System.Linq.Expressions.Expression<System.Func<TLeftSourceItem, TRightSourceItem, bool>>":
				result =  "(i1, i2) => i1.Num == i2.Num";
				break;
			case "System.Linq.Expressions.Expression<System.Func<TOuterSourceItem, TInnerSourceItem, bool>>":
				result =  "(i1, i2) => i1.Num == i2.Num";
				break;
			case "System.Linq.Expressions.Expression<System.Func<TSourceItem, TOrderingValue>>":
				result =  "i => i";
				break;
			case "System.ComponentModel.ListSortDirection":
				result =  "System.ComponentModel.ListSortDirection.Ascending";
				break;
			case "System.Collections.Generic.IComparer<TOrderingValue>":
				result =  "Comparer<int>.Default";
				break;
			case "System.Linq.Expressions.Expression<System.Func<TSourceItem, TResultItem>>":
				result =  "i => i.Num";
				break;
			case "int":
				if (argumentName.Contains("pageSize")) result = "2";
				else if (argumentName.Contains("initialPage")) result = "1";
				else if (argumentName.Contains("currentPage")) result = "1";
				else if (argumentName.Contains("Capacity")) result = "100";
				else result =  argumentName.Contains("count") ? "3" : "0";
				break;
			case "int?":
				result = "null";
				break;
			case "ObservableComputations.IOrdering<TSourceItem>":
				result =  "getItems().Selecting(i => i.Num).Ordering(i => i)";
				sourceAccessor = ".GetValueAs(s => ((Ordering<int, int>)s)?.Source)?.GetValueAs(s => ((Selecting<Item, int>)s)?.Source)";
				break;
			case "System.Func<TSourceItem, TResult, TResult>":
				result = argumentName == "aggregateFunc" ? "(i, r) => i + r" : "(i, r) => r - i";
				break;
			case "System.Linq.Expressions.Expression<System.Func<TSourceItem, int, bool>>":
				result =  "(i, ind) => i.Active";
				break;
			case "string":
				result =  @"""&""";
				break;
			case "System.Linq.Expressions.Expression<System.Func<TResult>>":
				result =  "() => 1";
				break;
			case "System.Collections.Generic.IComparer<TSourceItem>":
				result =  "Comparer<int>.Default";
				break;
			case "System.Linq.Expressions.Expression<System.Func<TSourceItem, System.Collections.Specialized.INotifyCollectionChanged>>":
				result =  "i => i.Items";
				break;
			case "System.Linq.Expressions.Expression<System.Func<TSourceItem, int, System.Collections.Specialized.INotifyCollectionChanged>>":
				result =  "(i, ind) => i.Items";
				break;
			case "ObservableComputations.IReadScalar<TResult>":
				break;
			case "bool":
				result = "true";
				break;
			case "ObservableComputations.CollectionPausingResumeType":
				result = "CollectionPausingResumeType.Reset";
				break;
			default:
				throw new Exception($"Unexpected type {type}");
		}

		string scalarType;
		if (variableType == null)
		{
			variableType = getTestType(type, extensionMethodName);
			scalarType = getTestType(checkingType, extensionMethodName);
			if (scalar) result = $"getScalar<{scalarType}>({result})";
		}
		else
		{
			if (scalar) result = $"getScalar<{variableType}>({result})";
			scalarType = variableType;
			variableType = scalar ? $"IReadScalar<{getTestType(checkingType, extensionMethodName)}>" : variableType;
		}

		return (result, sourceAccessor, variableType, scalarType, isCombinatoricalArgument(type, argumentName, extensionMethodName));
	}

	private IEnumerable<string> getScalarAlternativeValues(string scalarType, string argumentName, string extensionMethodName)
	{
		List<string> result = new List<string>();

		switch (scalarType)
		{
			case "System.Collections.Specialized.INotifyCollectionChanged":
			case "ObservableCollection<Item>":
			case "ObservableCollection<ObservableCollection<Item>>":
				result.Add("null");
				break;
			case "Item":
				if (extensionMethodName == "Maximazing"
					|| extensionMethodName == "Minimazing")
					result.Add("1");
				else if (extensionMethodName == "FirstComputing"
					|| extensionMethodName == "LastComputing")
					result.Add("new QuickTests.Item(1, true)");
				else
					result.Add("null");
				break;
			case "System.Collections.Generic.IEqualityComparer<Item>":
				if (extensionMethodName != "ContainsComputing"
					&& extensionMethodName != "Excepting"
					&& extensionMethodName != "Intersecting") 
					result.Add("null");
				break;
			case "System.Collections.Generic.IEqualityComparer<int>":
				result.Add("null");
				break;
			case "System.ComponentModel.ListSortDirection":
				result.Add("System.ComponentModel.ListSortDirection.Descending");
				break;
			case "System.Collections.Generic.IComparer<int>":
				result.Add("null");
				break;
			case "int":
				result.Add(argumentName.Contains("count") ? "4" : "1");
				break;
			case "int?":
				result.Add("1");
				result.Add("1");
				break;
			case "ObservableComputations.IOrdering<int>":
				result.Add("null");
				break;
			case "string":
				result.Add(@"""&&&""");
				result.Add(@"""&&""");
				break;
			case "System.Collections.Generic.IComparer<Item>":
				result.Add("null");
				break;
			case "Selecting<Item, int>":
				result.Add("null");
				break;
			case "Selecting<Item, string>":
				result.Add("null");
				break;
			case "bool":
				result.Add("false");
				result.Add("true");
				break;
			case "ObservableComputations.CollectionPausingResumeType":
				result.Add("CollectionPausingResumeType.ReplayChanges");
				result.Add("CollectionPausingResumeType.Reset");
				break;
			default:
				throw new Exception($"Unexpected scalar type {scalarType}");
		}


		return result;
	}

	private bool isCombinatoricalArgument(string type, string argumentName, string extensionMethodName)
	{
		return type == "bool" || type == "int" || type == "int?" || type == "ObservableComputations.CollectionPausingResumeType";
	}
#>
