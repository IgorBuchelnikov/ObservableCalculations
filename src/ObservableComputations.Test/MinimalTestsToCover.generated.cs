// Copyright (c) 2019-2021 Buchelnikov Igor Vladimirovich. All rights reserved
// Buchelnikov Igor Vladimirovich licenses this file to you under the MIT license.
// The LICENSE file is located at https://github.com/IgorBuchelnikov/ObservableComputations/blob/master/LICENSE

// This file was generated by the following commands:
// cd <path to repository>\src\ObservableComputations.Test
// dotnet test  /p:AltCover=true /p:AltCoverStrongNameKey=assembly_strong_name_key.snk /p:DefineConstants=GeneratingMinimalTestsToCover

using System.ComponentModel;
using NUnit.Framework;

namespace ObservableComputations.Test
{
	public partial class AllComputingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class AnyComputingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class AppendingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class AveragingTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{});
			test(new int[]{-2});
			test(new int[]{-2, -2});
			test(new int[]{-2, -2, -2});
			test(new int[]{-2, -2, -2, -2});
			test(new int[]{-2, -2, -2, -2, -2});
			test(new int[]{-2, -2, -2, -2, -1});
			test(new int[]{-2, -2, -2, -1});
			test(new int[]{-2, -2, -1});
			test(new int[]{-2, -2, 2});
			test(new int[]{-2, -1});
			test(new int[]{-1});

		}
	}	

	public partial class CastingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class CollectionDispatchingTest
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class CollectionProcessingVoidTest
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class ComputingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class ConcatenatingTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{-1});
			test(new int[]{-1, -1});
			test(new int[]{-1, -1, -1});
			test(new int[]{-1, -1, -1, -1});
			test(new int[]{-1, -1, -1, 0});
			test(new int[]{-1, -1, -1, 1});
			test(new int[]{-1, -1, 0});
			test(new int[]{-1, -1, 1, -1});
			test(new int[]{-1, -1, 1, 1});
			test(new int[]{-1, 0});
			test(new int[]{-1, 1, 3, 3});
			test(new int[]{0});

		}
	}	

	public partial class ContainsComputingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class DictionaringTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{});
			test(new int[]{-1});
			test(new int[]{-1, -1});
			test(new int[]{-1, -1, -1});
			test(new int[]{-1, -1, -1, -1});
			test(new int[]{-1, -1, -1, -1, -1});
			test(new int[]{-1, -1, -1, -1, 0});
			test(new int[]{-1, -1, -1, 0});
			test(new int[]{-1, -1, 0});
			test(new int[]{-1, -1, 1, -1, 1});
			test(new int[]{-1, 0});
			test(new int[]{0});

		}
	}	

	public partial class DifferingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class DistinctingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class ExceptingTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{}, new int[]{});
			test(new int[]{-1}, new int[]{});
			test(new int[]{-1}, new int[]{-1});
			test(new int[]{-1, -1}, new int[]{-1});
			test(new int[]{-1, -1}, new int[]{-1, -1});
			test(new int[]{-1, -1}, new int[]{-1, 0});
			test(new int[]{-1, 0}, new int[]{-1});
			test(new int[]{-1}, new int[]{0});
			test(new int[]{0}, new int[]{});

		}
	}	

	public partial class ExpressionWatcherTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class FilteringTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class FirstComputingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class GroupingTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{});
			test(new int[]{-1});
			test(new int[]{-1, -1});
			test(new int[]{-1, -1, -1});
			test(new int[]{-1, -1, -1, -1});
			test(new int[]{-1, -1, -1, -1, -1});
			test(new int[]{-1, -1, -1, -1, 0});
			test(new int[]{-1, -1, -1, 0});
			test(new int[]{-1, -1, -1, 0, 1});
			test(new int[]{-1, -1, 0});
			test(new int[]{-1, -1, 1, -1, 1});
			test(new int[]{-1, 0});
			test(new int[]{0});

		}
	}	

	public partial class GroupJoiningTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{}, new int[]{});
			test(new int[]{-1, -1}, new int[]{});
			test(new int[]{}, new int[]{-1, -1});
			test(new int[]{-1, -1, -1, -1}, new int[]{-1, -1, -1, -1});
			test(new int[]{-1, -1, -1, -1}, new int[]{-1, -1});
			test(new int[]{-1, -1}, new int[]{-1, -1, -1, -1});
			test(new int[]{-1, -1, -1, 0}, new int[]{-1, -1, -1, 0});
			test(new int[]{-1, -1, -1, 0}, new int[]{-1, -1});
			test(new int[]{-1, -1, 0, -1}, new int[]{-1, -1, 0, -1});
			test(new int[]{-1, 0}, new int[]{});
			test(new int[]{0, -1}, new int[]{});

		}
	}	

	public partial class HashSettingTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{});
			test(new int[]{-1});
			test(new int[]{-1, -1});
			test(new int[]{-1, -1, -1});
			test(new int[]{-1, -1, -1, -1});
			test(new int[]{-1, -1, -1, -1, -1});
			test(new int[]{-1, -1, -1, -1, 0});
			test(new int[]{-1, -1, -1, 0});
			test(new int[]{-1, -1, 0});
			test(new int[]{-1, -1, 1, -1, 1});
			test(new int[]{-1, 0});
			test(new int[]{0});

		}
	}	

	public partial class IndicesComputingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class IntersectingTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{}, new int[]{});
			test(new int[]{-1}, new int[]{});
			test(new int[]{-1}, new int[]{-1});
			test(new int[]{-1, -1}, new int[]{-1});
			test(new int[]{-1, -1}, new int[]{-1, -1});
			test(new int[]{-1, -1}, new int[]{-1, 0});
			test(new int[]{-1, 0}, new int[]{-1});
			test(new int[]{-1}, new int[]{0});
			test(new int[]{0}, new int[]{});

		}
	}	

	public partial class ItemComputingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class JoiningTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{}, new int[]{});
			test(new int[]{-1, -1}, new int[]{});
			test(new int[]{}, new int[]{-1, -1});
			test(new int[]{-1, -1, -1, -1}, new int[]{-1, -1, -1, -1});
			test(new int[]{-1, -1, -1, -1}, new int[]{-1, -1});
			test(new int[]{-1, -1}, new int[]{-1, -1, -1, -1});
			test(new int[]{-1, -1, -1, 0}, new int[]{-1, -1, -1, 0});
			test(new int[]{-1, -1, 0, -1}, new int[]{-1, -1, 0, -1});
			test(new int[]{-1, -1, 0, 0}, new int[]{-1, -1, 0, 0});
			test(new int[]{-1, 0}, new int[]{});
			test(new int[]{0, -1}, new int[]{});

		}
	}	

	public partial class LastComputingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class MinimazingOrMaximazingTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{}, MinimazingOrMaximazingMode.Maximazing);
			test(new int[]{-2}, MinimazingOrMaximazingMode.Maximazing);
			test(new int[]{-2, -2}, MinimazingOrMaximazingMode.Maximazing);
			test(new int[]{-2, -2, -2}, MinimazingOrMaximazingMode.Maximazing);
			test(new int[]{-2, -2, -2, -2}, MinimazingOrMaximazingMode.Maximazing);
			test(new int[]{-2, -2, -2, -2, -2}, MinimazingOrMaximazingMode.Maximazing);
			test(new int[]{-2, -2, -2, -2, -1}, MinimazingOrMaximazingMode.Maximazing);
			test(new int[]{-2, -2, -2, -2, 0}, MinimazingOrMaximazingMode.Maximazing);
			test(new int[]{-2, -2, -2, -1}, MinimazingOrMaximazingMode.Maximazing);
			test(new int[]{-2, -2, -1}, MinimazingOrMaximazingMode.Maximazing);
			test(new int[]{-2, -2, 2}, MinimazingOrMaximazingMode.Maximazing);
			test(new int[]{-2, -1}, MinimazingOrMaximazingMode.Maximazing);
			test(new int[]{-1}, MinimazingOrMaximazingMode.Maximazing);
			test(new int[]{}, MinimazingOrMaximazingMode.Minimazing);

		}
	}	

	public partial class OfTypeComputingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class OrderingTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{}, ListSortDirection.Ascending);
			test(new int[]{-1}, ListSortDirection.Ascending);
			test(new int[]{-1, -1}, ListSortDirection.Ascending);
			test(new int[]{-1, -1, -1}, ListSortDirection.Ascending);
			test(new int[]{-1, -1, -1, -1}, ListSortDirection.Ascending);
			test(new int[]{-1, -1, -1, -1, -1}, ListSortDirection.Ascending);
			test(new int[]{-1, -1, -1, -1, 0}, ListSortDirection.Ascending);
			test(new int[]{-1, -1, -1, -1, 1}, ListSortDirection.Ascending);
			test(new int[]{-1, -1, -1, 0}, ListSortDirection.Ascending);
			test(new int[]{-1, -1, 0}, ListSortDirection.Ascending);
			test(new int[]{-1, -1, 1, -1, 1}, ListSortDirection.Ascending);
			test(new int[]{-1, 0}, ListSortDirection.Ascending);
			test(new int[]{-1, 0, 1, 1}, ListSortDirection.Ascending);
			test(new int[]{0}, ListSortDirection.Ascending);
			test(new int[]{0, 0}, ListSortDirection.Ascending);
			test(new int[]{}, ListSortDirection.Descending);

		}
	}	

	public partial class OrderingThenOrderingTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{0, 0, 0}, new int[]{1, -1, -1}, ListSortDirection.Ascending);
			test(new int[]{2, 0, 4, 3, 3, 3}, new int[]{-1, 4, -1, 4, 2, 0}, ListSortDirection.Ascending);
			test(new int[]{0, 3, 1, 0, 3}, new int[]{0, 3, 1, -1, 0}, ListSortDirection.Ascending);
			test(new int[]{-1}, new int[]{-1}, ListSortDirection.Ascending);
			test(new int[]{-1}, new int[]{0}, ListSortDirection.Ascending);
			test(new int[]{-1, -1}, new int[]{-1, -1}, ListSortDirection.Ascending);
			test(new int[]{-1, -1}, new int[]{-1, 0}, ListSortDirection.Ascending);
			test(new int[]{-1, -1, -1}, new int[]{-1, -1, -1}, ListSortDirection.Ascending);
			test(new int[]{-1, -1, -1}, new int[]{-1, -1, 0}, ListSortDirection.Ascending);
			test(new int[]{-1, -1, 0}, new int[]{-1, -1, -1}, ListSortDirection.Ascending);
			test(new int[]{-1, 0}, new int[]{-1, -1}, ListSortDirection.Ascending);
			test(new int[]{0}, new int[]{-1}, ListSortDirection.Ascending);
			test(new int[]{1, 2, 0, 0, 1}, new int[]{0, 2, 1, 3, 2}, ListSortDirection.Descending);

		}
	}	

	public partial class OrderingThenOrderingThenOrderingTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{0, 5, 1, 4, 3, 3}, new int[]{0, 2, 0, 3, 4, 4}, new int[]{1, -1, 3, 5, 4, 5}, ListSortDirection.Ascending, ListSortDirection.Ascending);
			test(new int[]{4, 1, 4, 2, 5, 4}, new int[]{5, 3, 0, 0, 5, 0}, new int[]{-1, 4, 1, 2, -1, 1}, ListSortDirection.Ascending, ListSortDirection.Ascending);
			test(new int[]{2, -1, 0, 1, 1, 0}, new int[]{2, 0, 3, 3, 2, 0}, new int[]{0, 3, 2, 0, 0, 3}, ListSortDirection.Ascending, ListSortDirection.Ascending);
			test(new int[]{-1}, new int[]{-1}, new int[]{-1}, ListSortDirection.Ascending, ListSortDirection.Ascending);
			test(new int[]{-1, -1}, new int[]{-1, -1}, new int[]{-1, -1}, ListSortDirection.Ascending, ListSortDirection.Ascending);
			test(new int[]{-1, -1}, new int[]{-1, -1}, new int[]{-1, 0}, ListSortDirection.Ascending, ListSortDirection.Ascending);
			test(new int[]{-1, -1}, new int[]{-1, -1}, new int[]{0, -1}, ListSortDirection.Ascending, ListSortDirection.Ascending);
			test(new int[]{-1, -1}, new int[]{-1, 0}, new int[]{-1, -1}, ListSortDirection.Ascending, ListSortDirection.Ascending);
			test(new int[]{-1}, new int[]{-1}, new int[]{0}, ListSortDirection.Ascending, ListSortDirection.Ascending);
			test(new int[]{-1, -1}, new int[]{0, 1}, new int[]{0, -1}, ListSortDirection.Ascending, ListSortDirection.Ascending);
			test(new int[]{-1}, new int[]{0}, new int[]{-1}, ListSortDirection.Ascending, ListSortDirection.Ascending);
			test(new int[]{0}, new int[]{-1}, new int[]{-1}, ListSortDirection.Ascending, ListSortDirection.Ascending);
			test(new int[]{-1, -1, 0, 1, 4, 1}, new int[]{2, 2, 1, 5, 1, 0}, new int[]{5, 5, 3, 5, 0, 4}, ListSortDirection.Ascending, ListSortDirection.Descending);

		}
	}	

	public partial class PagingTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(0);
			test(1);
			test(2);
			test(3);
			test(4);

		}
	}	

	public partial class PredicateGroupJoiningTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{}, new int[]{});
			test(new int[]{-1}, new int[]{});
			test(new int[]{-1}, new int[]{-1});
			test(new int[]{-1, -1}, new int[]{-1});
			test(new int[]{-1, -1}, new int[]{-1, -1});
			test(new int[]{-1, -1}, new int[]{-1, 0});
			test(new int[]{-1, 0}, new int[]{-1});
			test(new int[]{-1}, new int[]{0});
			test(new int[]{0}, new int[]{});

		}
	}	

	public partial class PrependingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class PreviousTrackingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class PropertyAccessingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class ReversingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class ScalarProcessingTest
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class ScalarProcessingVoidTest
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class SelectingManyTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class SelectingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class SequenceTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class SkippingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class SkippingWhileTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class SpecialCaseTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class StringsConcatenatingTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{});
			test(new int[]{-1});
			test(new int[]{-1, -1});
			test(new int[]{-1, -1, -1});
			test(new int[]{-1, -1, -1, -1});
			test(new int[]{-1, -1, -1, 0});
			test(new int[]{-1, -1, -1, 1});
			test(new int[]{-1, -1, 0});
			test(new int[]{-1, 0});
			test(new int[]{-1, 1, 3, 3});
			test(new int[]{0});

		}
	}	

	public partial class SummarizingTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{});
			test(new int[]{-2});
			test(new int[]{-2, -2});
			test(new int[]{-2, -2, -2});
			test(new int[]{-2, -2, -2, -2});
			test(new int[]{-2, -2, -2, -2, -2});
			test(new int[]{-2, -2, -2, -2, -1});
			test(new int[]{-2, -2, -2, -1});
			test(new int[]{-2, -2, -1});
			test(new int[]{-2, -2, 2});
			test(new int[]{-2, -1});
			test(new int[]{-1});

		}
	}	

	public partial class TakingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class TakingWhileAltTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class TakingWhileTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class UnitingTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(new int[]{});
			test(new int[]{-1});
			test(new int[]{-1, -1});
			test(new int[]{-1, -1, -1});
			test(new int[]{-1, -1, -1, -1});
			test(new int[]{-1, -1, -1, 0});
			test(new int[]{-1, -1, -1, 1});
			test(new int[]{-1, -1, 0});
			test(new int[]{-1, 0});
			test(new int[]{-1, 1, 3, 3});
			test(new int[]{0});

		}
	}

	public partial class WeakPreviousTrackingTests
	{
		[Test]
		public void MinimalTestToCover()
		{

		}
	}	

	public partial class ZippingTests
	{
		[Test]
		public void MinimalTestToCover()
		{
			test(0, 0);
			test(0, 1);
			test(0, 2);
			test(1, 0);
			test(1, 2);
			test(2, 0);

		}
	}
}